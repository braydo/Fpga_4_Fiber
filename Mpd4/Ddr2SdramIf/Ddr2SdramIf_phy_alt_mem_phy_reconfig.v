// megafunction wizard: %ALTPLL_RECONFIG%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altpll_reconfig 

// ============================================================
// File Name: Ddr2SdramIf_phy_alt_mem_phy_reconfig.v
// Megafunction Name(s):
// 			altpll_reconfig
//
// Simulation Library Files(s):
// 			
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 13.0.1 Build 232 06/12/2013 SP 1 SJ Full Version
// ************************************************************


//Copyright (C) 1991-2013 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altpll_reconfig CBX_AUTO_BLACKBOX="ALL" device_family="Arria GX" init_from_rom="YES" pll_type="ENHANCED" scan_init_file="Ddr2SdramIf_phy_alt_mem_phy_pll.mif" busy clock counter_param counter_type data_in data_out pll_areset pll_areset_in pll_scanclk pll_scandata pll_scandataout pll_scandone pll_scanread pll_scanwrite read_param reconfig reset write_param
//VERSION_BEGIN 13.0 cbx_altpll_reconfig 2013:06:12:18:03:40:SJ cbx_altsyncram 2013:06:12:18:03:40:SJ cbx_cycloneii 2013:06:12:18:03:40:SJ cbx_lpm_add_sub 2013:06:12:18:03:40:SJ cbx_lpm_compare 2013:06:12:18:03:40:SJ cbx_lpm_counter 2013:06:12:18:03:40:SJ cbx_lpm_decode 2013:06:12:18:03:40:SJ cbx_lpm_mux 2013:06:12:18:03:40:SJ cbx_mgl 2013:06:12:18:04:42:SJ cbx_stratix 2013:06:12:18:03:40:SJ cbx_stratixii 2013:06:12:18:03:40:SJ cbx_stratixiii 2013:06:12:18:03:40:SJ cbx_stratixv 2013:06:12:18:03:40:SJ cbx_util_mgl 2013:06:12:18:03:40:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = altsyncram 2 lpm_counter 3 reg 42 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  Ddr2SdramIf_phy_alt_mem_phy_reconfig_pllrcfg_7321
	( 
	busy,
	clock,
	counter_param,
	counter_type,
	data_in,
	data_out,
	pll_areset,
	pll_areset_in,
	pll_scanclk,
	pll_scandata,
	pll_scandataout,
	pll_scandone,
	pll_scanread,
	pll_scanwrite,
	read_param,
	reconfig,
	reset,
	write_param) /* synthesis synthesis_clearbox=2 */;
	output   busy;
	input   clock;
	input   [2:0]  counter_param;
	input   [3:0]  counter_type;
	input   [8:0]  data_in;
	output   [8:0]  data_out;
	output   pll_areset;
	input   pll_areset_in;
	output   pll_scanclk;
	output   pll_scandata;
	input   pll_scandataout;
	input   pll_scandone;
	output   pll_scanread;
	output   pll_scanwrite;
	input   read_param;
	input   reconfig;
	input   reset;
	input   write_param;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   [2:0]  counter_param;
	tri0   [3:0]  counter_type;
	tri0   [8:0]  data_in;
	tri0   pll_areset_in;
	tri0   pll_scandataout;
	tri0   pll_scandone;
	tri0   read_param;
	tri0   reconfig;
	tri0   write_param;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [0:0]   wire_altsyncram3_q_a;
	wire  [0:0]   wire_altsyncram4_q_a;
	reg	[7:0]	addr_counter_out_reg;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	already_inited_from_rom_reg;
	reg	[2:0]	counter_param_latch_reg;
	reg	[3:0]	counter_type_latch_reg;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	idle_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	read_data_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	read_first_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	read_init_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	read_last_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_init_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_post_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_tx_data_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_tx_ena_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_tx_last_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	reconfig_wait_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=HIGH"} *)
	reg	reset_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	scan_cache_same_since_reconfig_reg;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	scan_rom_init_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	scan_rom_write_state;
	reg	[8:0]	shift_reg;
	wire	[8:0]	wire_shift_reg_clrn;
	wire	[8:0]	wire_shift_reg_ena;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	write_data_state;
	(* ALTERA_ATTRIBUTE = {"POWER_UP_LEVEL=LOW"} *)
	reg	write_init_state;
	wire  [7:0]   wire_cntr1_q;
	wire  [3:0]   wire_cntr2_q;
	wire  wire_timeout_ctr_cout;
	wire  addr_counter_done;
	wire  addr_counter_enable;
	wire  [7:0]  addr_counter_out;
	wire  addr_counter_sload;
	wire  [7:0]  addr_counter_sload_value;
	wire  [7:0]  addr_decoder_out;
	wire  [7:0]  const_scan_chain_size;
	wire  [2:0]  counter_param_latch;
	wire  [3:0]  counter_type_latch;
	wire  dummy_scandataout;
	wire  input_latch_enable;
	wire  power_up;
	wire  reconfig_done;
	wire  reconfig_post_done;
	wire  [7:0]  scan_cache_address;
	wire  scan_cache_in;
	wire  scan_cache_in_select;
	wire  scan_cache_out;
	wire  scan_cache_write_enable;
	wire  [7:0]  scan_rom_address;
	wire  scan_rom_out;
	wire  sel_param_bypass;
	wire  sel_param_high_nominal_i;
	wire  sel_param_low_spread_r;
	wire  sel_param_odd_spread_bypass;
	wire  sel_param_phase_c;
	wire  sel_type_c0;
	wire  sel_type_c1;
	wire  sel_type_c2;
	wire  sel_type_c3;
	wire  sel_type_c4;
	wire  sel_type_c5;
	wire  sel_type_cplf;
	wire  sel_type_m;
	wire  sel_type_n;
	wire  shift_reg_clear;
	wire  shift_reg_load_enable;
	wire  shift_reg_serial_in;
	wire  shift_reg_serial_out;
	wire  shift_reg_shift_enable;
	wire  [7:0]  shift_reg_width_select;
	wire  timedout;
	wire  width_counter_done;
	wire  width_counter_enable;
	wire  width_counter_sload;
	wire  [3:0]  width_counter_sload_value;
	wire  [3:0]  width_decoder_out;
	wire  [7:0]  width_decoder_select;

	altsyncram   altsyncram3
	( 
	.address_a(scan_cache_address),
	.clock0(clock),
	.data_a({scan_cache_in}),
	.eccstatus(),
	.q_a(wire_altsyncram3_q_a),
	.q_b(),
	.wren_a(scan_cache_write_enable)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr0(1'b0),
	.aclr1(1'b0),
	.address_b({1{1'b1}}),
	.addressstall_a(1'b0),
	.addressstall_b(1'b0),
	.byteena_a({1{1'b1}}),
	.byteena_b({1{1'b1}}),
	.clock1(1'b1),
	.clocken0(1'b1),
	.clocken1(1'b1),
	.clocken2(1'b1),
	.clocken3(1'b1),
	.data_b({1{1'b1}}),
	.rden_a(1'b1),
	.rden_b(1'b1),
	.wren_b(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		altsyncram3.numwords_a = 174,
		altsyncram3.operation_mode = "SINGLE_PORT",
		altsyncram3.width_a = 1,
		altsyncram3.width_byteena_a = 1,
		altsyncram3.widthad_a = 8,
		altsyncram3.intended_device_family = "Arria GX",
		altsyncram3.lpm_type = "altsyncram";
	altsyncram   altsyncram4
	( 
	.address_a(scan_rom_address),
	.clock0(clock),
	.eccstatus(),
	.q_a(wire_altsyncram4_q_a),
	.q_b()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr0(1'b0),
	.aclr1(1'b0),
	.address_b({1{1'b1}}),
	.addressstall_a(1'b0),
	.addressstall_b(1'b0),
	.byteena_a({1{1'b1}}),
	.byteena_b({1{1'b1}}),
	.clock1(1'b1),
	.clocken0(1'b1),
	.clocken1(1'b1),
	.clocken2(1'b1),
	.clocken3(1'b1),
	.data_a({1{1'b1}}),
	.data_b({1{1'b1}}),
	.rden_a(1'b1),
	.rden_b(1'b1),
	.wren_a(1'b0),
	.wren_b(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		altsyncram4.init_file = "Ddr2SdramIf_phy_alt_mem_phy_pll.mif",
		altsyncram4.numwords_a = 174,
		altsyncram4.operation_mode = "ROM",
		altsyncram4.width_a = 1,
		altsyncram4.widthad_a = 8,
		altsyncram4.intended_device_family = "Arria GX",
		altsyncram4.lpm_type = "altsyncram";
	// synopsys translate_off
	initial
		addr_counter_out_reg = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) addr_counter_out_reg <= 8'b0;
		else  addr_counter_out_reg <= addr_counter_out;
	// synopsys translate_off
	initial
		already_inited_from_rom_reg = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		  already_inited_from_rom_reg <= (idle_state | already_inited_from_rom_reg);
	// synopsys translate_off
	initial
		counter_param_latch_reg = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) counter_param_latch_reg <= 3'b0;
		else if  (input_latch_enable == 1'b1)   counter_param_latch_reg <= counter_param;
	// synopsys translate_off
	initial
		counter_type_latch_reg = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) counter_type_latch_reg <= 4'b0;
		else if  (input_latch_enable == 1'b1)   counter_type_latch_reg <= counter_type;
	// synopsys translate_off
	initial
		idle_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) idle_state <= 1'b0;
		else  idle_state <= ((((((((idle_state & (~ read_param)) & (~ write_param)) & (~ reconfig)) | read_last_state) | (write_data_state & width_counter_done)) | (reconfig_wait_state & reconfig_done)) | (scan_rom_write_state & addr_counter_done)) | (reset_state & already_inited_from_rom_reg));
	// synopsys translate_off
	initial
		read_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_data_state <= 1'b0;
		else  read_data_state <= ((read_first_state & (~ width_counter_done)) | (read_data_state & (~ width_counter_done)));
	// synopsys translate_off
	initial
		read_first_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_first_state <= 1'b0;
		else  read_first_state <= read_init_state;
	// synopsys translate_off
	initial
		read_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_init_state <= 1'b0;
		else  read_init_state <= (idle_state & read_param);
	// synopsys translate_off
	initial
		read_last_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_last_state <= 1'b0;
		else  read_last_state <= ((read_first_state & width_counter_done) | (read_data_state & width_counter_done));
	// synopsys translate_off
	initial
		reconfig_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_init_state <= 1'b0;
		else  reconfig_init_state <= (idle_state & reconfig);
	// synopsys translate_off
	initial
		reconfig_post_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_post_state <= 1'b0;
		else  reconfig_post_state <= ((reconfig_tx_last_state | (reconfig_post_state & (~ reconfig_post_done))) | (reconfig_init_state & scan_cache_same_since_reconfig_reg));
	// synopsys translate_off
	initial
		reconfig_tx_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_tx_data_state <= 1'b0;
		else  reconfig_tx_data_state <= (reconfig_tx_ena_state | (reconfig_tx_data_state & (~ addr_counter_done)));
	// synopsys translate_off
	initial
		reconfig_tx_ena_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_tx_ena_state <= 1'b0;
		else  reconfig_tx_ena_state <= (reconfig_init_state & (~ scan_cache_same_since_reconfig_reg));
	// synopsys translate_off
	initial
		reconfig_tx_last_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_tx_last_state <= 1'b0;
		else  reconfig_tx_last_state <= (reconfig_tx_data_state & addr_counter_done);
	// synopsys translate_off
	initial
		reconfig_wait_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reconfig_wait_state <= 1'b0;
		else  reconfig_wait_state <= ((reconfig_post_state & reconfig_post_done) | (reconfig_wait_state & (~ reconfig_done)));
	// synopsys translate_off
	initial
		reset_state = {1{1'b1}};
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) reset_state <= {1{1'b1}};
		else  reset_state <= power_up;
	// synopsys translate_off
	initial
		scan_cache_same_since_reconfig_reg = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) scan_cache_same_since_reconfig_reg <= 1'b0;
		else  scan_cache_same_since_reconfig_reg <= ((~ write_init_state) & (reconfig_post_state | scan_cache_same_since_reconfig_reg));
	// synopsys translate_off
	initial
		scan_rom_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) scan_rom_init_state <= 1'b0;
		else  scan_rom_init_state <= (reset_state & (~ already_inited_from_rom_reg));
	// synopsys translate_off
	initial
		scan_rom_write_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) scan_rom_write_state <= 1'b0;
		else  scan_rom_write_state <= (scan_rom_init_state | (scan_rom_write_state & (~ addr_counter_done)));
	// synopsys translate_off
	initial
		shift_reg[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[0:0])
		if (wire_shift_reg_clrn[0:0] == 1'b0) shift_reg[0:0] <= 1'b0;
		else if  (wire_shift_reg_ena[0:0] == 1'b1)   shift_reg[0:0] <= ((shift_reg_load_enable & data_in[0]) | ((~ shift_reg_load_enable) & shift_reg_serial_in));
	// synopsys translate_off
	initial
		shift_reg[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[1:1])
		if (wire_shift_reg_clrn[1:1] == 1'b0) shift_reg[1:1] <= 1'b0;
		else if  (wire_shift_reg_ena[1:1] == 1'b1)   shift_reg[1:1] <= ((shift_reg_load_enable & data_in[1]) | ((~ shift_reg_load_enable) & shift_reg[0:0]));
	// synopsys translate_off
	initial
		shift_reg[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[2:2])
		if (wire_shift_reg_clrn[2:2] == 1'b0) shift_reg[2:2] <= 1'b0;
		else if  (wire_shift_reg_ena[2:2] == 1'b1)   shift_reg[2:2] <= ((shift_reg_load_enable & data_in[2]) | ((~ shift_reg_load_enable) & shift_reg[1:1]));
	// synopsys translate_off
	initial
		shift_reg[3:3] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[3:3])
		if (wire_shift_reg_clrn[3:3] == 1'b0) shift_reg[3:3] <= 1'b0;
		else if  (wire_shift_reg_ena[3:3] == 1'b1)   shift_reg[3:3] <= ((shift_reg_load_enable & data_in[3]) | ((~ shift_reg_load_enable) & shift_reg[2:2]));
	// synopsys translate_off
	initial
		shift_reg[4:4] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[4:4])
		if (wire_shift_reg_clrn[4:4] == 1'b0) shift_reg[4:4] <= 1'b0;
		else if  (wire_shift_reg_ena[4:4] == 1'b1)   shift_reg[4:4] <= ((shift_reg_load_enable & data_in[4]) | ((~ shift_reg_load_enable) & shift_reg[3:3]));
	// synopsys translate_off
	initial
		shift_reg[5:5] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[5:5])
		if (wire_shift_reg_clrn[5:5] == 1'b0) shift_reg[5:5] <= 1'b0;
		else if  (wire_shift_reg_ena[5:5] == 1'b1)   shift_reg[5:5] <= ((shift_reg_load_enable & data_in[5]) | ((~ shift_reg_load_enable) & shift_reg[4:4]));
	// synopsys translate_off
	initial
		shift_reg[6:6] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[6:6])
		if (wire_shift_reg_clrn[6:6] == 1'b0) shift_reg[6:6] <= 1'b0;
		else if  (wire_shift_reg_ena[6:6] == 1'b1)   shift_reg[6:6] <= ((shift_reg_load_enable & data_in[6]) | ((~ shift_reg_load_enable) & shift_reg[5:5]));
	// synopsys translate_off
	initial
		shift_reg[7:7] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[7:7])
		if (wire_shift_reg_clrn[7:7] == 1'b0) shift_reg[7:7] <= 1'b0;
		else if  (wire_shift_reg_ena[7:7] == 1'b1)   shift_reg[7:7] <= ((shift_reg_load_enable & data_in[7]) | ((~ shift_reg_load_enable) & shift_reg[6:6]));
	// synopsys translate_off
	initial
		shift_reg[8:8] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  negedge wire_shift_reg_clrn[8:8])
		if (wire_shift_reg_clrn[8:8] == 1'b0) shift_reg[8:8] <= 1'b0;
		else if  (wire_shift_reg_ena[8:8] == 1'b1)   shift_reg[8:8] <= ((shift_reg_load_enable & data_in[8]) | ((~ shift_reg_load_enable) & shift_reg[7:7]));
	assign
		wire_shift_reg_ena = {9{(shift_reg_load_enable | shift_reg_shift_enable)}},
		wire_shift_reg_clrn = {9{(~ (shift_reg_clear | reset))}};
	// synopsys translate_off
	initial
		write_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_data_state <= 1'b0;
		else  write_data_state <= (write_init_state | (write_data_state & (~ width_counter_done)));
	// synopsys translate_off
	initial
		write_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_init_state <= 1'b0;
		else  write_init_state <= (idle_state & write_param);
	lpm_counter   cntr1
	( 
	.clock(clock),
	.cnt_en(addr_counter_enable),
	.cout(),
	.data(addr_counter_sload_value),
	.eq(),
	.q(wire_cntr1_q),
	.sload(addr_counter_sload)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.clk_en(1'b1),
	.sclr(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr1.lpm_direction = "DOWN",
		cntr1.lpm_modulus = 174,
		cntr1.lpm_port_updown = "PORT_UNUSED",
		cntr1.lpm_width = 8,
		cntr1.lpm_type = "lpm_counter";
	lpm_counter   cntr2
	( 
	.clock(clock),
	.cnt_en(width_counter_enable),
	.cout(),
	.data(width_counter_sload_value),
	.eq(),
	.q(wire_cntr2_q),
	.sload(width_counter_sload)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.clk_en(1'b1),
	.sclr(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr2.lpm_direction = "DOWN",
		cntr2.lpm_port_updown = "PORT_UNUSED",
		cntr2.lpm_width = 4,
		cntr2.lpm_type = "lpm_counter";
	lpm_counter   timeout_ctr
	( 
	.clock(clock),
	.cnt_en(reconfig_wait_state),
	.cout(wire_timeout_ctr_cout),
	.eq(),
	.q(),
	.sclr(pll_scandone)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.clk_en(1'b1),
	.data({6{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		timeout_ctr.lpm_direction = "UP",
		timeout_ctr.lpm_modulus = 40,
		timeout_ctr.lpm_port_updown = "PORT_UNUSED",
		timeout_ctr.lpm_width = 6,
		timeout_ctr.lpm_type = "lpm_counter";
	assign
		addr_counter_done = ((((((((~ wire_cntr1_q[0]) & (~ wire_cntr1_q[1])) & (~ wire_cntr1_q[2])) & (~ wire_cntr1_q[3])) & (~ wire_cntr1_q[4])) & (~ wire_cntr1_q[5])) & (~ wire_cntr1_q[6])) & (~ wire_cntr1_q[7])),
		addr_counter_enable = (((((read_first_state | read_data_state) | write_data_state) | reconfig_tx_data_state) | reconfig_tx_ena_state) | scan_rom_write_state),
		addr_counter_out = wire_cntr1_q,
		addr_counter_sload = (((read_init_state | write_init_state) | reconfig_init_state) | scan_rom_init_state),
		addr_counter_sload_value = (((addr_decoder_out & {8{(read_init_state | write_init_state)}}) | (const_scan_chain_size & {8{reconfig_init_state}})) | (const_scan_chain_size & {8{scan_rom_init_state}})),
		addr_decoder_out = ((((((((((((((((((((((((((((((((((((((((({{6{1'b0}}, {2{(sel_type_cplf & sel_param_high_nominal_i)}}} | {{4{1'b0}}, (sel_type_cplf & sel_param_low_spread_r), {2{1'b0}}, (sel_type_cplf & sel_param_low_spread_r)}) | {{4{1'b0}}, (sel_type_cplf & sel_param_phase_c), 1'b0, {2{(sel_type_cplf & sel_param_phase_c)}}}) | {{4{1'b0}}, {2{(sel_type_m & sel_param_phase_c)}}, 1'b0, (sel_type_m & sel_param_phase_c)}) | {{4{1'b0}}, {4{(sel_type_c0 & sel_param_phase_c)}}}) | {{3{1'b0}}, (sel_type_c1 & sel_param_phase_c), {3{1'b0}}, (sel_type_c1 & sel_param_phase_c)}) | {{3{1'b0}}, (sel_type_c2 & sel_param_phase_c), {2{1'b0}}, {2{(sel_type_c2 & sel_param_phase_c)}}}) | {{3{1'b0}}, (sel_type_c3 & sel_param_phase_c), 1'b0, (sel_type_c3 & sel_param_phase_c), 1'b0, (sel_type_c3 & sel_param_phase_c)}) | {{3{1'b0}}, (sel_type_c4 & sel_param_phase_c), 1'b0, {3{(sel_type_c4 & sel_param_phase_c)}}}) | {{3{1'b0}}, {2{(sel_type_c5 & sel_param_phase_c)}}, {2{1'b0}}, (sel_type_c5 & sel_param_phase_c)}) | {{2{1'b0}}, (sel_type_c5 & sel_param_high_nominal_i), {4{1'b0}}, (sel_type_c5 & sel_param_high_nominal_i)}) | {{2{1'b0}}, (sel_type_c5 & sel_param_bypass), {3{1'b0}}, (sel_type_c5 & sel_param_bypass), 1'b0}) | {{2{1'b0}}, (sel_type_c5 & sel_param_low_spread_r), 1'b0, (sel_type_c5 & sel_param_low_spread_r), 1'b0, (sel_type_c5 & sel_param_low_spread_r), 1'b0}) | {{2{1'b0}}, (sel_type_c5 & sel_param_odd_spread_bypass), 1'b0, (sel_type_c5 & sel_param_odd_spread_bypass), 1'b0, {2{(sel_type_c5 & sel_param_odd_spread_bypass)}}}) | {{2{1'b0}}, {2{(sel_type_c4 & sel_param_high_nominal_i)}}, {2{1'b0}}, {2{(sel_type_c4 & sel_param_high_nominal_i)}}}) | {{2{1'b0}}, {2{(sel_type_c4 & sel_param_bypass)}}, 1'b0, (sel_type_c4 & sel_param_bypass), {2{1'b0}}}) | {{2{1'b0}}, {4{(sel_type_c4 & sel_param_low_spread_r)}}, {2{1'b0}}}) | {{2{1'b0}}, {4{(sel_type_c4 & sel_param_odd_spread_bypass)}}, 1'b0, (sel_type_c4 & sel_param_odd_spread_bypass)}) | {1'b0, (sel_type_c3 & sel_param_high_nominal_i), {3{1'b0}}, (sel_type_c3 & sel_param_high_nominal_i
), 1'b0, (sel_type_c3 & sel_param_high_nominal_i)}) | {1'b0, (sel_type_c3 & sel_param_bypass), {3{1'b0}}, {2{(sel_type_c3 & sel_param_bypass)}}, 1'b0}) | {1'b0, (sel_type_c3 & sel_param_low_spread_r), {2{1'b0}}, {3{(sel_type_c3 & sel_param_low_spread_r)}}, 1'b0}) | {1'b0, (sel_type_c3 & sel_param_odd_spread_bypass), {2{1'b0}}, {4{(sel_type_c3 & sel_param_odd_spread_bypass)}}}) | {1'b0, (sel_type_c2 & sel_param_high_nominal_i), 1'b0, (sel_type_c2 & sel_param_high_nominal_i), 1'b0, {3{(sel_type_c2 & sel_param_high_nominal_i)}}}) | {1'b0, (sel_type_c2 & sel_param_bypass), 1'b0, {2{(sel_type_c2 & sel_param_bypass)}}, {3{1'b0}}}) | {1'b0, {2{(sel_type_c2 & sel_param_low_spread_r)}}, {5{1'b0}}}) | {1'b0, {2{(sel_type_c2 & sel_param_odd_spread_bypass)}}, {4{1'b0}}, (sel_type_c2 & sel_param_odd_spread_bypass)}) | {1'b0, {2{(sel_type_c1 & sel_param_high_nominal_i)}}, 1'b0, (sel_type_c1 & sel_param_high_nominal_i), {2{1'b0}}, (sel_type_c1 & sel_param_high_nominal_i)}) | {1'b0, {2{(sel_type_c1 & sel_param_bypass)}}, 1'b0, (sel_type_c1 & sel_param_bypass), 1'b0, (sel_type_c1 & sel_param_bypass), 1'b0}) | {1'b0, {3{(sel_type_c1 & sel_param_low_spread_r)}}, {2{1'b0}}, (sel_type_c1 & sel_param_low_spread_r), 1'b0}) | {1'b0, {3{(sel_type_c1 & sel_param_odd_spread_bypass)}}, {2{1'b0}}, {2{(sel_type_c1 & sel_param_odd_spread_bypass)}}}) | {1'b0, {4{(sel_type_c0 & sel_param_high_nominal_i)}}, 1'b0, {2{(sel_type_c0 & sel_param_high_nominal_i)}}}) | {1'b0, {5{(sel_type_c0 & sel_param_bypass)}}, {2{1'b0}}}) | {(sel_type_c0 & sel_param_low_spread_r), {4{1'b0}}, (sel_type_c0 & sel_param_low_spread_r), {2{1'b0}}}) | {(sel_type_c0 & sel_param_odd_spread_bypass), {4{1'b0}}, (sel_type_c0 & sel_param_odd_spread_bypass), 1'b0, (sel_type_c0 & sel_param_odd_spread_bypass)}) | {(sel_type_m & sel_param_high_nominal_i), {3{1'b0}}, {3{(sel_type_m & sel_param_high_nominal_i)}}, 1'b0}) | {(sel_type_m & sel_param_bypass), {3{1'b0}}, {4{(sel_type_m & sel_param_bypass)}}}) | {(sel_type_m & sel_param_low_spread_r), {2{1'b0}}, {2{(sel_type_m & sel_param_low_spread_r
)}}, {3{1'b0}}}) | {(sel_type_m & sel_param_odd_spread_bypass), {2{1'b0}}, {2{(sel_type_m & sel_param_odd_spread_bypass)}}, {2{1'b0}}, (sel_type_m & sel_param_odd_spread_bypass)}) | {(sel_type_n & sel_param_high_nominal_i), 1'b0, (sel_type_n & sel_param_high_nominal_i), {3{1'b0}}, (sel_type_n & sel_param_high_nominal_i), 1'b0}) | {(sel_type_n & sel_param_bypass), 1'b0, (sel_type_n & sel_param_bypass), {3{1'b0}}, {2{(sel_type_n & sel_param_bypass)}}}) | {(sel_type_n & sel_param_low_spread_r), 1'b0, (sel_type_n & sel_param_low_spread_r), 1'b0, {2{(sel_type_n & sel_param_low_spread_r)}}, {2{1'b0}}}) | {(sel_type_n & sel_param_odd_spread_bypass), 1'b0, (sel_type_n & sel_param_odd_spread_bypass), 1'b0, {2{(sel_type_n & sel_param_odd_spread_bypass)}}, 1'b0, (sel_type_n & sel_param_odd_spread_bypass)}),
		busy = (~ idle_state),
		const_scan_chain_size = 8'b10101101,
		counter_param_latch = counter_param_latch_reg,
		counter_type_latch = counter_type_latch_reg,
		data_out = shift_reg,
		dummy_scandataout = pll_scandataout,
		input_latch_enable = (idle_state & (write_param | read_param)),
		pll_areset = pll_areset_in,
		pll_scanclk = clock,
		pll_scandata = (scan_cache_out & ((reconfig_tx_data_state | reconfig_tx_last_state) | reconfig_post_state)),
		pll_scanread = (reconfig_tx_ena_state | reconfig_tx_data_state),
		pll_scanwrite = reconfig_wait_state,
		power_up = ((((((((((((((((~ reset_state) & (~ idle_state)) & (~ scan_rom_init_state)) & (~ scan_rom_write_state)) & (~ read_init_state)) & (~ read_first_state)) & (~ read_data_state)) & (~ read_last_state)) & (~ write_init_state)) & (~ write_data_state)) & (~ reconfig_init_state)) & (~ reconfig_tx_ena_state)) & (~ reconfig_tx_data_state)) & (~ reconfig_tx_last_state)) & (~ reconfig_post_state)) & (~ reconfig_wait_state)),
		reconfig_done = ((pll_scandone | timedout) & (dummy_scandataout | (~ dummy_scandataout))),
		reconfig_post_done = (~ (pll_scandone | timedout)),
		scan_cache_address = (({8{scan_cache_in_select}} & addr_counter_out_reg) | ({8{(~ scan_cache_in_select)}} & (addr_counter_out & {8{addr_counter_enable}}))),
		scan_cache_in = ((scan_cache_in_select & scan_rom_out) | ((~ scan_cache_in_select) & shift_reg_serial_out)),
		scan_cache_in_select = (scan_rom_init_state | scan_rom_write_state),
		scan_cache_out = wire_altsyncram3_q_a[0],
		scan_cache_write_enable = (write_data_state | scan_rom_write_state),
		scan_rom_address = addr_counter_out,
		scan_rom_out = wire_altsyncram4_q_a[0],
		sel_param_bypass = (((~ counter_param_latch[0]) & (~ counter_param_latch[1])) & counter_param_latch[2]),
		sel_param_high_nominal_i = (((~ counter_param_latch[0]) & (~ counter_param_latch[1])) & (~ counter_param_latch[2])),
		sel_param_low_spread_r = ((counter_param_latch[0] & (~ counter_param_latch[1])) & (~ counter_param_latch[2])),
		sel_param_odd_spread_bypass = ((counter_param_latch[0] & (~ counter_param_latch[1])) & counter_param_latch[2]),
		sel_param_phase_c = (((~ counter_param_latch[0]) & counter_param_latch[1]) & (~ counter_param_latch[2])),
		sel_type_c0 = ((((~ counter_type_latch[0]) & (~ counter_type_latch[1])) & counter_type_latch[2]) & (~ counter_type_latch[3])),
		sel_type_c1 = (((counter_type_latch[0] & (~ counter_type_latch[1])) & counter_type_latch[2]) & (~ counter_type_latch[3])),
		sel_type_c2 = ((((~ counter_type_latch[0]) & counter_type_latch[1]) & counter_type_latch[2]) & (~ counter_type_latch[3])),
		sel_type_c3 = (((counter_type_latch[0] & counter_type_latch[1]) & counter_type_latch[2]) & (~ counter_type_latch[3])),
		sel_type_c4 = ((((~ counter_type_latch[0]) & (~ counter_type_latch[1])) & (~ counter_type_latch[2])) & counter_type_latch[3]),
		sel_type_c5 = (((counter_type_latch[0] & (~ counter_type_latch[1])) & (~ counter_type_latch[2])) & counter_type_latch[3]),
		sel_type_cplf = ((((~ counter_type_latch[0]) & counter_type_latch[1]) & (~ counter_type_latch[2])) & (~ counter_type_latch[3])),
		sel_type_m = (((counter_type_latch[0] & (~ counter_type_latch[1])) & (~ counter_type_latch[2])) & (~ counter_type_latch[3])),
		sel_type_n = ((((~ counter_type_latch[0]) & (~ counter_type_latch[1])) & (~ counter_type_latch[2])) & (~ counter_type_latch[3])),
		shift_reg_clear = read_init_state,
		shift_reg_load_enable = (idle_state & write_param),
		shift_reg_serial_in = scan_cache_out,
		shift_reg_serial_out = ((((((((shift_reg[0:0] & shift_reg_width_select[0]) | (shift_reg[3:3] & shift_reg_width_select[1])) | (shift_reg[8:8] & shift_reg_width_select[2])) | (shift_reg[1:1] & shift_reg_width_select[3])) | (shift_reg[5:5] & shift_reg_width_select[4])) | (shift_reg[7:7] & shift_reg_width_select[5])) | (shift_reg[2:2] & shift_reg_width_select[6])) | (shift_reg[4:4] & shift_reg_width_select[7])),
		shift_reg_shift_enable = ((read_data_state | read_last_state) | write_data_state),
		shift_reg_width_select = width_decoder_select,
		timedout = wire_timeout_ctr_cout,
		width_counter_done = ((((~ wire_cntr2_q[0]) & (~ wire_cntr2_q[1])) & (~ wire_cntr2_q[2])) & (~ wire_cntr2_q[3])),
		width_counter_enable = ((read_first_state | read_data_state) | write_data_state),
		width_counter_sload = (read_init_state | write_init_state),
		width_counter_sload_value = width_decoder_out,
		width_decoder_out = ((((({4{1'b0}} | {{2{1'b0}}, {2{width_decoder_select[1]}}}) | {width_decoder_select[2], {3{1'b0}}}) | {{3{1'b0}}, width_decoder_select[3]}) | {1'b0, width_decoder_select[4], 1'b0, width_decoder_select[4]}) | {1'b0, {3{width_decoder_select[5]}}}),
		width_decoder_select = {{2{1'b0}}, ((((((((((((sel_type_c5 & sel_param_high_nominal_i) | (sel_type_c5 & sel_param_low_spread_r)) | (sel_type_c4 & sel_param_high_nominal_i)) | (sel_type_c4 & sel_param_low_spread_r)) | (sel_type_c3 & sel_param_high_nominal_i)) | (sel_type_c3 & sel_param_low_spread_r)) | (sel_type_c2 & sel_param_high_nominal_i)) | (sel_type_c2 & sel_param_low_spread_r)) | (sel_type_c1 & sel_param_high_nominal_i)) | (sel_type_c1 & sel_param_low_spread_r)) | (sel_type_c0 & sel_param_high_nominal_i)) | (sel_type_c0 & sel_param_low_spread_r)), (sel_type_cplf & sel_param_low_spread_r), ((((((((sel_type_cplf & sel_param_phase_c) | (sel_type_m & sel_param_phase_c)) | (sel_type_c0 & sel_param_phase_c)) | (sel_type_c1 & sel_param_phase_c)) | (sel_type_c2 & sel_param_phase_c)) | (sel_type_c3 & sel_param_phase_c)) | (sel_type_c4 & sel_param_phase_c)) | (sel_type_c5 & sel_param_phase_c)), ((((sel_type_m & sel_param_high_nominal_i) | (sel_type_m & sel_param_low_spread_r)) | (sel_type_n & sel_param_high_nominal_i)) | (sel_type_n & sel_param_low_spread_r)), (sel_type_cplf & sel_param_high_nominal_i), ((((((((((((((((sel_type_c5 & sel_param_bypass) | (sel_type_c5 & sel_param_odd_spread_bypass)) | (sel_type_c4 & sel_param_bypass)) | (sel_type_c4 & sel_param_odd_spread_bypass)) | (sel_type_c3 & sel_param_bypass)) | (sel_type_c3 & sel_param_odd_spread_bypass)) | (sel_type_c2 & sel_param_bypass)) | (sel_type_c2 & sel_param_odd_spread_bypass)) | (sel_type_c1 & sel_param_bypass)) | (sel_type_c1 & sel_param_odd_spread_bypass)) | (sel_type_c0 & sel_param_bypass)) | (sel_type_c0 & sel_param_odd_spread_bypass)) | (sel_type_m & sel_param_bypass)) | (sel_type_m & sel_param_odd_spread_bypass)) | (sel_type_n & sel_param_bypass)) | (sel_type_n & sel_param_odd_spread_bypass))};
endmodule //Ddr2SdramIf_phy_alt_mem_phy_reconfig_pllrcfg_7321
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module Ddr2SdramIf_phy_alt_mem_phy_reconfig (
	clock,
	counter_param,
	counter_type,
	data_in,
	pll_areset_in,
	pll_scandataout,
	pll_scandone,
	read_param,
	reconfig,
	reset,
	write_param,
	busy,
	data_out,
	pll_areset,
	pll_scanclk,
	pll_scandata,
	pll_scanread,
	pll_scanwrite)/* synthesis synthesis_clearbox = 2 */;

	input	  clock;
	input	[2:0]  counter_param;
	input	[3:0]  counter_type;
	input	[8:0]  data_in;
	input	  pll_areset_in;
	input	  pll_scandataout;
	input	  pll_scandone;
	input	  read_param;
	input	  reconfig;
	input	  reset;
	input	  write_param;
	output	  busy;
	output	[8:0]  data_out;
	output	  pll_areset;
	output	  pll_scanclk;
	output	  pll_scandata;
	output	  pll_scanread;
	output	  pll_scanwrite;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0	  pll_areset_in;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  sub_wire0;
	wire [8:0] sub_wire1;
	wire  sub_wire2;
	wire  sub_wire3;
	wire  sub_wire4;
	wire  sub_wire5;
	wire  sub_wire6;
	wire  pll_scanread = sub_wire0;
	wire [8:0] data_out = sub_wire1[8:0];
	wire  pll_scanclk = sub_wire2;
	wire  pll_scandata = sub_wire3;
	wire  busy = sub_wire4;
	wire  pll_areset = sub_wire5;
	wire  pll_scanwrite = sub_wire6;

	Ddr2SdramIf_phy_alt_mem_phy_reconfig_pllrcfg_7321	Ddr2SdramIf_phy_alt_mem_phy_reconfig_pllrcfg_7321_component (
				.counter_param (counter_param),
				.data_in (data_in),
				.counter_type (counter_type),
				.pll_areset_in (pll_areset_in),
				.reconfig (reconfig),
				.pll_scandataout (pll_scandataout),
				.pll_scandone (pll_scandone),
				.reset (reset),
				.write_param (write_param),
				.clock (clock),
				.read_param (read_param),
				.pll_scanread (sub_wire0),
				.data_out (sub_wire1),
				.pll_scanclk (sub_wire2),
				.pll_scandata (sub_wire3),
				.busy (sub_wire4),
				.pll_areset (sub_wire5),
				.pll_scanwrite (sub_wire6))/* synthesis synthesis_clearbox=2
	 clearbox_macroname = altpll_reconfig
	 clearbox_defparam = "init_from_rom=YES;intended_device_family=Arria GX;pll_type=ENHANCED;scan_init_file=Ddr2SdramIf_phy_alt_mem_phy_pll.mif;" */;

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: CHAIN_TYPE NUMERIC "0"
// Retrieval info: PRIVATE: INIT_FILE_NAME STRING "Ddr2SdramIf_phy_alt_mem_phy_pll.mif"
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Arria GX"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: PRIVATE: USE_INIT_FILE STRING "1"
// Retrieval info: CONSTANT: INIT_FROM_ROM STRING "YES"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Arria GX"
// Retrieval info: CONSTANT: PLL_TYPE STRING "ENHANCED"
// Retrieval info: CONSTANT: SCAN_INIT_FILE STRING "Ddr2SdramIf_phy_alt_mem_phy_pll.mif"
// Retrieval info: USED_PORT: busy 0 0 0 0 OUTPUT NODEFVAL "busy"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: USED_PORT: counter_param 0 0 3 0 INPUT NODEFVAL "counter_param[2..0]"
// Retrieval info: USED_PORT: counter_type 0 0 4 0 INPUT NODEFVAL "counter_type[3..0]"
// Retrieval info: USED_PORT: data_in 0 0 9 0 INPUT NODEFVAL "data_in[8..0]"
// Retrieval info: USED_PORT: data_out 0 0 9 0 OUTPUT NODEFVAL "data_out[8..0]"
// Retrieval info: USED_PORT: pll_areset 0 0 0 0 OUTPUT NODEFVAL "pll_areset"
// Retrieval info: USED_PORT: pll_areset_in 0 0 0 0 INPUT GND "pll_areset_in"
// Retrieval info: USED_PORT: pll_scanclk 0 0 0 0 OUTPUT NODEFVAL "pll_scanclk"
// Retrieval info: USED_PORT: pll_scandata 0 0 0 0 OUTPUT NODEFVAL "pll_scandata"
// Retrieval info: USED_PORT: pll_scandataout 0 0 0 0 INPUT NODEFVAL "pll_scandataout"
// Retrieval info: USED_PORT: pll_scandone 0 0 0 0 INPUT NODEFVAL "pll_scandone"
// Retrieval info: USED_PORT: pll_scanread 0 0 0 0 OUTPUT NODEFVAL "pll_scanread"
// Retrieval info: USED_PORT: pll_scanwrite 0 0 0 0 OUTPUT NODEFVAL "pll_scanwrite"
// Retrieval info: USED_PORT: read_param 0 0 0 0 INPUT NODEFVAL "read_param"
// Retrieval info: USED_PORT: reconfig 0 0 0 0 INPUT NODEFVAL "reconfig"
// Retrieval info: USED_PORT: reset 0 0 0 0 INPUT NODEFVAL "reset"
// Retrieval info: USED_PORT: write_param 0 0 0 0 INPUT NODEFVAL "write_param"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: @counter_param 0 0 3 0 counter_param 0 0 3 0
// Retrieval info: CONNECT: @counter_type 0 0 4 0 counter_type 0 0 4 0
// Retrieval info: CONNECT: @data_in 0 0 9 0 data_in 0 0 9 0
// Retrieval info: CONNECT: @pll_areset_in 0 0 0 0 pll_areset_in 0 0 0 0
// Retrieval info: CONNECT: @pll_scandataout 0 0 0 0 pll_scandataout 0 0 0 0
// Retrieval info: CONNECT: @pll_scandone 0 0 0 0 pll_scandone 0 0 0 0
// Retrieval info: CONNECT: @read_param 0 0 0 0 read_param 0 0 0 0
// Retrieval info: CONNECT: @reconfig 0 0 0 0 reconfig 0 0 0 0
// Retrieval info: CONNECT: @reset 0 0 0 0 reset 0 0 0 0
// Retrieval info: CONNECT: @write_param 0 0 0 0 write_param 0 0 0 0
// Retrieval info: CONNECT: busy 0 0 0 0 @busy 0 0 0 0
// Retrieval info: CONNECT: data_out 0 0 9 0 @data_out 0 0 9 0
// Retrieval info: CONNECT: pll_areset 0 0 0 0 @pll_areset 0 0 0 0
// Retrieval info: CONNECT: pll_scanclk 0 0 0 0 @pll_scanclk 0 0 0 0
// Retrieval info: CONNECT: pll_scandata 0 0 0 0 @pll_scandata 0 0 0 0
// Retrieval info: CONNECT: pll_scanread 0 0 0 0 @pll_scanread 0 0 0 0
// Retrieval info: CONNECT: pll_scanwrite 0 0 0 0 @pll_scanwrite 0 0 0 0
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig.inc TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig.cmp TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig.bsf TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig_inst.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL alt_mem_phy_reconfig_bb.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL Ddr2SdramIf_phy_alt_mem_phy_reconfig_bb.v TRUE
