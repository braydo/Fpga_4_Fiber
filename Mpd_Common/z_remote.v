// megafunction wizard: %ALTREMOTE_UPDATE%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altremote_update 

// ============================================================
// File Name: z_remote.v
// Megafunction Name(s):
// 			altremote_update
//
// Simulation Library Files(s):
// 			arriagx;lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 13.0.1 Build 232 06/12/2013 SP 1 SJ Full Version
// ************************************************************


//Copyright (C) 1991-2013 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altremote_update CBX_AUTO_BLACKBOX="ALL" check_app_pof="false" DEVICE_FAMILY="Arria GX" operation_mode="active_serial_remote" sim_init_config="factory" sim_init_page_select=1 sim_init_status=0 sim_init_watchdog_value=0 busy clock data_in data_out param read_param reconfig reset reset_timer write_param
//VERSION_BEGIN 13.0 cbx_altremote_update 2013:06:12:18:03:43:SJ cbx_cycloneii 2013:06:12:18:03:43:SJ cbx_lpm_add_sub 2013:06:12:18:03:43:SJ cbx_lpm_compare 2013:06:12:18:03:43:SJ cbx_lpm_counter 2013:06:12:18:03:43:SJ cbx_lpm_decode 2013:06:12:18:03:43:SJ cbx_lpm_shiftreg 2013:06:12:18:03:43:SJ cbx_mgl 2013:06:12:18:05:10:SJ cbx_stratix 2013:06:12:18:03:43:SJ cbx_stratixii 2013:06:12:18:03:43:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = arriagx_rublock 1 lpm_counter 2 reg 30 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
(* ALTERA_ATTRIBUTE = {"suppress_da_rule_internal=c104;suppress_da_rule_internal=C101;suppress_da_rule_internal=C103"} *)
module  z_remote_rmtupdt_ols
	( 
	busy,
	clock,
	data_in,
	data_out,
	param,
	read_param,
	reconfig,
	reset,
	reset_timer,
	write_param) /* synthesis synthesis_clearbox=2 */;
	output   busy;
	input   clock;
	input   [11:0]  data_in;
	output   [11:0]  data_out;
	input   [2:0]  param;
	input   read_param;
	input   reconfig;
	input   reset;
	input   reset_timer;
	input   write_param;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   [11:0]  data_in;
	tri0   [2:0]  param;
	tri0   read_param;
	tri0   reconfig;
	tri0   reset_timer;
	tri0   write_param;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[0:0]	check_busy_dffe;
	reg	[11:0]	dffe4a;
	wire	[11:0]	wire_dffe4a_ena;
	reg	dffe5;
	reg	[2:0]	dffe6a;
	wire	[2:0]	wire_dffe6a_ena;
	reg	idle_state;
	reg	idle_write_wait;
	reg	read_data_state;
	reg	read_init_counter_state;
	reg	read_init_state;
	reg	read_post_state;
	reg	read_pre_data_state;
	reg	write_data_state;
	reg	write_init_counter_state;
	reg	write_init_state;
	reg	write_load_state;
	reg	write_post_data_state;
	reg	write_pre_data_state;
	reg	write_wait_state;
	wire  [4:0]   wire_cntr2_q;
	wire  [3:0]   wire_cntr3_q;
	wire  wire_sd1_regout;
	wire  bit_counter_all_done;
	wire  bit_counter_clear;
	wire  bit_counter_enable;
	wire  [4:0]  bit_counter_param_start;
	wire  bit_counter_param_start_match;
	wire  idle;
	wire  [2:0]  param_decoder_param_latch;
	wire  [4:0]  param_decoder_select;
	wire  power_up;
	wire  read_data;
	wire  read_init;
	wire  read_init_counter;
	wire  read_post;
	wire  read_pre_data;
	wire  rublock_captnupdt;
	wire  rublock_clock;
	wire  rublock_reconfig;
	wire  rublock_reconfig_st;
	wire  rublock_regin;
	wire  rublock_regout;
	wire  rublock_regout_reg;
	wire  rublock_shiftnld;
	wire  select_shift_nloop;
	wire  shift_reg_clear;
	wire  shift_reg_load_enable;
	wire  shift_reg_serial_in;
	wire  shift_reg_serial_out;
	wire  shift_reg_shift_enable;
	wire  [4:0]  start_bit_decoder_out;
	wire  [4:0]  start_bit_decoder_param_select;
	wire  [4:0]  w19w;
	wire  [3:0]  w43w;
	wire  width_counter_all_done;
	wire  width_counter_clear;
	wire  width_counter_enable;
	wire  [3:0]  width_counter_param_width;
	wire  width_counter_param_width_match;
	wire  [3:0]  width_decoder_out;
	wire  [4:0]  width_decoder_param_select;
	wire  write_data;
	wire  write_init;
	wire  write_init_counter;
	wire  write_load;
	wire  write_post_data;
	wire  write_pre_data;
	wire  write_wait;

	// synopsys translate_off
	initial 
		 check_busy_dffe[0:0] = 0;
	// synopsys translate_on
	// synopsys translate_off
	initial
		dffe4a[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[0:0] <= 1'b0;
		else if  (wire_dffe4a_ena[0:0] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[0:0] <= 1'b0;
			else  dffe4a[0:0] <= ((shift_reg_load_enable & data_in[0]) | ((~ shift_reg_load_enable) & dffe4a[1:1]));
	// synopsys translate_off
	initial
		dffe4a[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[1:1] <= 1'b0;
		else if  (wire_dffe4a_ena[1:1] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[1:1] <= 1'b0;
			else  dffe4a[1:1] <= ((shift_reg_load_enable & data_in[1]) | ((~ shift_reg_load_enable) & dffe4a[2:2]));
	// synopsys translate_off
	initial
		dffe4a[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[2:2] <= 1'b0;
		else if  (wire_dffe4a_ena[2:2] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[2:2] <= 1'b0;
			else  dffe4a[2:2] <= ((shift_reg_load_enable & data_in[2]) | ((~ shift_reg_load_enable) & dffe4a[3:3]));
	// synopsys translate_off
	initial
		dffe4a[3:3] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[3:3] <= 1'b0;
		else if  (wire_dffe4a_ena[3:3] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[3:3] <= 1'b0;
			else  dffe4a[3:3] <= ((shift_reg_load_enable & data_in[3]) | ((~ shift_reg_load_enable) & dffe4a[4:4]));
	// synopsys translate_off
	initial
		dffe4a[4:4] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[4:4] <= 1'b0;
		else if  (wire_dffe4a_ena[4:4] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[4:4] <= 1'b0;
			else  dffe4a[4:4] <= ((shift_reg_load_enable & data_in[4]) | ((~ shift_reg_load_enable) & dffe4a[5:5]));
	// synopsys translate_off
	initial
		dffe4a[5:5] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[5:5] <= 1'b0;
		else if  (wire_dffe4a_ena[5:5] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[5:5] <= 1'b0;
			else  dffe4a[5:5] <= ((shift_reg_load_enable & data_in[5]) | ((~ shift_reg_load_enable) & dffe4a[6:6]));
	// synopsys translate_off
	initial
		dffe4a[6:6] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[6:6] <= 1'b0;
		else if  (wire_dffe4a_ena[6:6] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[6:6] <= 1'b0;
			else  dffe4a[6:6] <= ((shift_reg_load_enable & data_in[6]) | ((~ shift_reg_load_enable) & dffe4a[7:7]));
	// synopsys translate_off
	initial
		dffe4a[7:7] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[7:7] <= 1'b0;
		else if  (wire_dffe4a_ena[7:7] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[7:7] <= 1'b0;
			else  dffe4a[7:7] <= ((shift_reg_load_enable & data_in[7]) | ((~ shift_reg_load_enable) & dffe4a[8:8]));
	// synopsys translate_off
	initial
		dffe4a[8:8] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[8:8] <= 1'b0;
		else if  (wire_dffe4a_ena[8:8] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[8:8] <= 1'b0;
			else  dffe4a[8:8] <= ((shift_reg_load_enable & data_in[8]) | ((~ shift_reg_load_enable) & dffe4a[9:9]));
	// synopsys translate_off
	initial
		dffe4a[9:9] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[9:9] <= 1'b0;
		else if  (wire_dffe4a_ena[9:9] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[9:9] <= 1'b0;
			else  dffe4a[9:9] <= ((shift_reg_load_enable & data_in[9]) | ((~ shift_reg_load_enable) & dffe4a[10:10]));
	// synopsys translate_off
	initial
		dffe4a[10:10] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[10:10] <= 1'b0;
		else if  (wire_dffe4a_ena[10:10] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[10:10] <= 1'b0;
			else  dffe4a[10:10] <= ((shift_reg_load_enable & data_in[10]) | ((~ shift_reg_load_enable) & dffe4a[11:11]));
	// synopsys translate_off
	initial
		dffe4a[11:11] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe4a[11:11] <= 1'b0;
		else if  (wire_dffe4a_ena[11:11] == 1'b1) 
			if (shift_reg_clear == 1'b1) dffe4a[11:11] <= 1'b0;
			else  dffe4a[11:11] <= ((shift_reg_load_enable & data_in[11]) | ((~ shift_reg_load_enable) & shift_reg_serial_in));
	assign
		wire_dffe4a_ena = {12{((shift_reg_load_enable | shift_reg_shift_enable) | shift_reg_clear)}};
	// synopsys translate_off
	initial
		dffe5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe5 <= 1'b0;
		else  dffe5 <= rublock_regout;
	// synopsys translate_off
	initial
		dffe6a[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe6a[0:0] <= 1'b0;
		else if  (wire_dffe6a_ena[0:0] == 1'b1)   dffe6a[0:0] <= param[0:0];
	// synopsys translate_off
	initial
		dffe6a[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe6a[1:1] <= 1'b0;
		else if  (wire_dffe6a_ena[1:1] == 1'b1)   dffe6a[1:1] <= param[1:1];
	// synopsys translate_off
	initial
		dffe6a[2:2] = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) dffe6a[2:2] <= 1'b0;
		else if  (wire_dffe6a_ena[2:2] == 1'b1)   dffe6a[2:2] <= param[2:2];
	assign
		wire_dffe6a_ena = {3{(idle & (write_param | read_param))}};
	// synopsys translate_off
	initial
		idle_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) idle_state <= {1{1'b1}};
		else  idle_state <= ((((((idle & (~ read_param)) & (~ write_param)) | write_wait) | (read_data & width_counter_all_done)) | (read_post & width_counter_all_done)) | power_up);
	// synopsys translate_off
	initial
		idle_write_wait = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) idle_write_wait <= 1'b0;
		else  idle_write_wait <= (((((((idle & (~ read_param)) & (~ write_param)) | write_wait) | (read_data & width_counter_all_done)) | (read_post & width_counter_all_done)) | power_up) & write_load);
	// synopsys translate_off
	initial
		read_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_data_state <= 1'b0;
		else  read_data_state <= (((read_init_counter & bit_counter_param_start_match) | (read_pre_data & bit_counter_param_start_match)) | ((read_data & (~ width_counter_param_width_match)) & (~ width_counter_all_done)));
	// synopsys translate_off
	initial
		read_init_counter_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_init_counter_state <= 1'b0;
		else  read_init_counter_state <= read_init;
	// synopsys translate_off
	initial
		read_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_init_state <= 1'b0;
		else  read_init_state <= (idle & read_param);
	// synopsys translate_off
	initial
		read_post_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_post_state <= 1'b0;
		else  read_post_state <= (((read_data & width_counter_param_width_match) & (~ width_counter_all_done)) | (read_post & (~ width_counter_all_done)));
	// synopsys translate_off
	initial
		read_pre_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) read_pre_data_state <= 1'b0;
		else  read_pre_data_state <= ((read_init_counter & (~ bit_counter_param_start_match)) | (read_pre_data & (~ bit_counter_param_start_match)));
	// synopsys translate_off
	initial
		write_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_data_state <= 1'b0;
		else  write_data_state <= (((write_init_counter & bit_counter_param_start_match) | (write_pre_data & bit_counter_param_start_match)) | ((write_data & (~ width_counter_param_width_match)) & (~ bit_counter_all_done)));
	// synopsys translate_off
	initial
		write_init_counter_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_init_counter_state <= 1'b0;
		else  write_init_counter_state <= write_init;
	// synopsys translate_off
	initial
		write_init_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_init_state <= 1'b0;
		else  write_init_state <= (idle & write_param);
	// synopsys translate_off
	initial
		write_load_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_load_state <= 1'b0;
		else  write_load_state <= ((write_data & bit_counter_all_done) | (write_post_data & bit_counter_all_done));
	// synopsys translate_off
	initial
		write_post_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_post_data_state <= 1'b0;
		else  write_post_data_state <= (((write_data & width_counter_param_width_match) & (~ bit_counter_all_done)) | (write_post_data & (~ bit_counter_all_done)));
	// synopsys translate_off
	initial
		write_pre_data_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_pre_data_state <= 1'b0;
		else  write_pre_data_state <= ((write_init_counter & (~ bit_counter_param_start_match)) | (write_pre_data & (~ bit_counter_param_start_match)));
	// synopsys translate_off
	initial
		write_wait_state = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge reset)
		if (reset == 1'b1) write_wait_state <= 1'b0;
		else  write_wait_state <= write_load;
	lpm_counter   cntr2
	( 
	.aclr(reset),
	.clock(clock),
	.cnt_en(bit_counter_enable),
	.cout(),
	.eq(),
	.q(wire_cntr2_q),
	.sclr(bit_counter_clear)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.clk_en(1'b1),
	.data({5{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr2.lpm_direction = "UP",
		cntr2.lpm_port_updown = "PORT_UNUSED",
		cntr2.lpm_width = 5,
		cntr2.lpm_type = "lpm_counter";
	lpm_counter   cntr3
	( 
	.aclr(reset),
	.clock(clock),
	.cnt_en(width_counter_enable),
	.cout(),
	.eq(),
	.q(wire_cntr3_q),
	.sclr(width_counter_clear)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.clk_en(1'b1),
	.data({4{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		cntr3.lpm_direction = "UP",
		cntr3.lpm_port_updown = "PORT_UNUSED",
		cntr3.lpm_width = 4,
		cntr3.lpm_type = "lpm_counter";
	arriagx_rublock   sd1
	( 
	.captnupdt(rublock_captnupdt),
	.clk(rublock_clock),
	.pgmout(),
	.rconfig(rublock_reconfig),
	.regin(rublock_regin),
	.regout(wire_sd1_regout),
	.rsttimer(reset_timer),
	.shiftnld(rublock_shiftnld));
	defparam
		sd1.operation_mode = "active_serial_remote",
		sd1.sim_init_config = "factory",
		sd1.sim_init_page_select = 1,
		sd1.sim_init_status = 0,
		sd1.sim_init_watchdog_value = 0,
		sd1.lpm_type = "arriagx_rublock";
	assign
		bit_counter_all_done = (((((~ wire_cntr2_q[0]) & wire_cntr2_q[1]) & (~ wire_cntr2_q[2])) & wire_cntr2_q[3]) & wire_cntr2_q[4]),
		bit_counter_clear = (read_init | write_init),
		bit_counter_enable = (((((((((read_init | write_init) | read_init_counter) | write_init_counter) | read_pre_data) | write_pre_data) | read_data) | write_data) | read_post) | write_post_data),
		bit_counter_param_start = start_bit_decoder_out,
		bit_counter_param_start_match = (((((~ w19w[0]) & (~ w19w[1])) & (~ w19w[2])) & (~ w19w[3])) & (~ w19w[4])),
		busy = (~ idle),
		data_out = dffe4a,
		idle = idle_state,
		param_decoder_param_latch = dffe6a,
		param_decoder_select = {((param_decoder_param_latch[0] & (~ param_decoder_param_latch[1])) & param_decoder_param_latch[2]), (((~ param_decoder_param_latch[0]) & (~ param_decoder_param_latch[1])) & param_decoder_param_latch[2]), ((param_decoder_param_latch[0] & param_decoder_param_latch[1]) & (~ param_decoder_param_latch[2])), (((~ param_decoder_param_latch[0]) & param_decoder_param_latch[1]) & (~ param_decoder_param_latch[2])), (((~ param_decoder_param_latch[0]) & (~ param_decoder_param_latch[1])) & (~ param_decoder_param_latch[2]))},
		power_up = (((((((((((((~ idle) & (~ read_init)) & (~ read_init_counter)) & (~ read_pre_data)) & (~ read_data)) & (~ read_post)) & (~ write_init)) & (~ write_init_counter)) & (~ write_pre_data)) & (~ write_data)) & (~ write_post_data)) & (~ write_load)) & (~ write_wait)),
		read_data = read_data_state,
		read_init = read_init_state,
		read_init_counter = read_init_counter_state,
		read_post = read_post_state,
		read_pre_data = read_pre_data_state,
		rublock_captnupdt = (~ write_load),
		rublock_clock = (~ (clock | idle_write_wait)),
		rublock_reconfig = rublock_reconfig_st,
		rublock_reconfig_st = (idle & reconfig),
		rublock_regin = ((rublock_regout_reg & (~ select_shift_nloop)) | (shift_reg_serial_out & select_shift_nloop)),
		rublock_regout = wire_sd1_regout,
		rublock_regout_reg = dffe5,
		rublock_shiftnld = (((((read_pre_data | write_pre_data) | read_data) | write_data) | read_post) | write_post_data),
		select_shift_nloop = ((read_data & (~ width_counter_param_width_match)) | (write_data & (~ width_counter_param_width_match))),
		shift_reg_clear = read_init,
		shift_reg_load_enable = (idle & write_param),
		shift_reg_serial_in = (rublock_regout_reg & select_shift_nloop),
		shift_reg_serial_out = dffe4a[0:0],
		shift_reg_shift_enable = (((read_data | write_data) | read_post) | write_post_data),
		start_bit_decoder_out = (((({5{1'b0}} | {1'b0, {3{start_bit_decoder_param_select[1]}}, 1'b0}) | {1'b0, {2{start_bit_decoder_param_select[2]}}, 1'b0, start_bit_decoder_param_select[2]}) | {{2{1'b0}}, {2{start_bit_decoder_param_select[3]}}, 1'b0}) | {{2{1'b0}}, start_bit_decoder_param_select[4], 1'b0, start_bit_decoder_param_select[4]}),
		start_bit_decoder_param_select = param_decoder_select,
		w19w = (wire_cntr2_q ^ bit_counter_param_start),
		w43w = (wire_cntr3_q ^ width_counter_param_width),
		width_counter_all_done = (((wire_cntr3_q[0] & wire_cntr3_q[1]) & (~ wire_cntr3_q[2])) & wire_cntr3_q[3]),
		width_counter_clear = (read_init | write_init),
		width_counter_enable = ((read_data | write_data) | read_post),
		width_counter_param_width = width_decoder_out,
		width_counter_param_width_match = ((((~ w43w[0]) & (~ w43w[1])) & (~ w43w[2])) & (~ w43w[3])),
		width_decoder_out = (((({1'b0, width_decoder_param_select[0], 1'b0, width_decoder_param_select[0]} | {{2{width_decoder_param_select[1]}}, {2{1'b0}}}) | {{3{1'b0}}, width_decoder_param_select[2]}) | {1'b0, {3{width_decoder_param_select[3]}}}) | {{3{1'b0}}, width_decoder_param_select[4]}),
		width_decoder_param_select = param_decoder_select,
		write_data = write_data_state,
		write_init = write_init_state,
		write_init_counter = write_init_counter_state,
		write_load = write_load_state,
		write_post_data = write_post_data_state,
		write_pre_data = write_pre_data_state,
		write_wait = write_wait_state;
endmodule //z_remote_rmtupdt_ols
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module z_remote (
	clock,
	data_in,
	param,
	read_param,
	reconfig,
	reset,
	reset_timer,
	write_param,
	busy,
	data_out)/* synthesis synthesis_clearbox = 2 */;

	input	  clock;
	input	[11:0]  data_in;
	input	[2:0]  param;
	input	  read_param;
	input	  reconfig;
	input	  reset;
	input	  reset_timer;
	input	  write_param;
	output	  busy;
	output	[11:0]  data_out;

	wire  sub_wire0;
	wire [11:0] sub_wire1;
	wire  busy = sub_wire0;
	wire [11:0] data_out = sub_wire1[11:0];

	z_remote_rmtupdt_ols	z_remote_rmtupdt_ols_component (
				.clock (clock),
				.data_in (data_in),
				.read_param (read_param),
				.param (param),
				.reconfig (reconfig),
				.reset (reset),
				.reset_timer (reset_timer),
				.write_param (write_param),
				.busy (sub_wire0),
				.data_out (sub_wire1))/* synthesis synthesis_clearbox=2
	 clearbox_macroname = altremote_update
	 clearbox_defparam = "check_app_pof=false;intended_device_family=Arria GX;operation_mode=ACTIVE_SERIAL_REMOTE;sim_init_config=FACTORY;sim_init_page_select=1;sim_init_status=0;sim_init_watchdog_value=0;" */;

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Arria GX"
// Retrieval info: PRIVATE: SIM_INIT_PAGE_SELECT_COMBO STRING "1"
// Retrieval info: PRIVATE: SIM_INIT_STAT_BIT0_CHECK STRING "0"
// Retrieval info: PRIVATE: SIM_INIT_STAT_BIT1_CHECK STRING "0"
// Retrieval info: PRIVATE: SIM_INIT_STAT_BIT2_CHECK STRING "0"
// Retrieval info: PRIVATE: SIM_INIT_STAT_BIT3_CHECK STRING "0"
// Retrieval info: PRIVATE: SIM_INIT_STAT_BIT4_CHECK STRING "0"
// Retrieval info: PRIVATE: SIM_INIT_WATCHDOG_VALUE_EDIT STRING "1"
// Retrieval info: PRIVATE: SUPPORT_WRITE_CHECK STRING "1"
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING "0"
// Retrieval info: PRIVATE: WATCHDOG_ENABLE_CHECK STRING "0"
// Retrieval info: CONSTANT: CHECK_APP_POF STRING "false"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Arria GX"
// Retrieval info: CONSTANT: OPERATION_MODE STRING "ACTIVE_SERIAL_REMOTE"
// Retrieval info: CONSTANT: SIM_INIT_CONFIG STRING "FACTORY"
// Retrieval info: CONSTANT: SIM_INIT_PAGE_SELECT NUMERIC "1"
// Retrieval info: CONSTANT: SIM_INIT_STATUS NUMERIC "0"
// Retrieval info: CONSTANT: SIM_INIT_WATCHDOG_VALUE NUMERIC "0"
// Retrieval info: USED_PORT: busy 0 0 0 0 OUTPUT NODEFVAL "busy"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: USED_PORT: data_in 0 0 12 0 INPUT NODEFVAL "data_in[11..0]"
// Retrieval info: USED_PORT: data_out 0 0 12 0 OUTPUT NODEFVAL "data_out[11..0]"
// Retrieval info: USED_PORT: param 0 0 3 0 INPUT NODEFVAL "param[2..0]"
// Retrieval info: USED_PORT: read_param 0 0 0 0 INPUT NODEFVAL "read_param"
// Retrieval info: USED_PORT: reconfig 0 0 0 0 INPUT NODEFVAL "reconfig"
// Retrieval info: USED_PORT: reset 0 0 0 0 INPUT NODEFVAL "reset"
// Retrieval info: USED_PORT: reset_timer 0 0 0 0 INPUT NODEFVAL "reset_timer"
// Retrieval info: USED_PORT: write_param 0 0 0 0 INPUT NODEFVAL "write_param"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: @data_in 0 0 12 0 data_in 0 0 12 0
// Retrieval info: CONNECT: @param 0 0 3 0 param 0 0 3 0
// Retrieval info: CONNECT: @read_param 0 0 0 0 read_param 0 0 0 0
// Retrieval info: CONNECT: @reconfig 0 0 0 0 reconfig 0 0 0 0
// Retrieval info: CONNECT: @reset 0 0 0 0 reset 0 0 0 0
// Retrieval info: CONNECT: @reset_timer 0 0 0 0 reset_timer 0 0 0 0
// Retrieval info: CONNECT: @write_param 0 0 0 0 write_param 0 0 0 0
// Retrieval info: CONNECT: busy 0 0 0 0 @busy 0 0 0 0
// Retrieval info: CONNECT: data_out 0 0 12 0 @data_out 0 0 12 0
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote_inst.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL z_remote_bb.v FALSE
// Retrieval info: LIB_FILE: arriagx
// Retrieval info: LIB_FILE: lpm
